[parse.y (info)] Line 701: 
Production Rules
(rule precedences determined from %prec or 1st terminal between parentheses):
1: translation_unit ->  function_definition
2: translation_unit ->  translation_unit function_definition
3: function_definition ->  type_specifier fun_declarator compound_statement
4: type_specifier (VOID) ->  VOID
5: type_specifier (INT) ->  INT
6: type_specifier (FLOAT) ->  FLOAT
7: fun_declarator (IDENTIFIER) ->  IDENTIFIER '(' parameter_list ')'
8: fun_declarator (IDENTIFIER) ->  IDENTIFIER '(' ')'
9: parameter_list ->  parameter_declaration
10: parameter_list (',') ->  parameter_list ',' parameter_declaration
11: parameter_declaration ->  type_specifier declarator
12: declarator (IDENTIFIER) ->  IDENTIFIER
13: declarator ('[') ->  declarator '[' constant_expression ']'
14: constant_expression (INT_CONSTANT) ->  INT_CONSTANT
15: constant_expression (FLOAT_CONSTANT) ->  FLOAT_CONSTANT
16: constant_expression (STRING_LITERAL) ->  STRING_LITERAL
17: compound_statement ('{') ->  '{' '}'
18: compound_statement ('{') ->  '{' statement_list '}'
19: compound_statement ('{') ->  '{' declaration_list statement_list '}'
20: statement_list ->  statement
21: statement_list ->  statement_list statement
22: statement ('{') ->  '{' statement_list '}'
23: statement ->  selection_statement
24: statement ->  iteration_statement
25: statement ->  assignment_statement
26: statement (RETURN) ->  RETURN expression ';'
27: assignment_statement (';') ->  ';'
28: assignment_statement ('=') ->  l_expression '=' expression ';'
29: expression ->  logical_and_expression
30: expression (OR_OP) ->  expression OR_OP logical_and_expression
31: logical_and_expression ->  equality_expression
32: logical_and_expression (AND_OP) ->  logical_and_expression AND_OP equality_expression
33: equality_expression ->  relational_expression
34: equality_expression (EQ_OP) ->  equality_expression EQ_OP relational_expression
35: equality_expression (NE_OP) ->  equality_expression NE_OP relational_expression
36: relational_expression ->  additive_expression
37: relational_expression ('<') ->  relational_expression '<' additive_expression
38: relational_expression ('>') ->  relational_expression '>' additive_expression
39: relational_expression (LE_OP) ->  relational_expression LE_OP additive_expression
40: relational_expression (GE_OP) ->  relational_expression GE_OP additive_expression
41: additive_expression ->  multiplicative_expression
42: additive_expression ('+') ->  additive_expression '+' multiplicative_expression
43: additive_expression ('-') ->  additive_expression '-' multiplicative_expression
44: multiplicative_expression ->  unary_expression
45: multiplicative_expression ('*') ->  multiplicative_expression '*' unary_expression
46: multiplicative_expression ('/') ->  multiplicative_expression '/' unary_expression
47: unary_expression ->  postfix_expression
48: unary_expression ->  unary_operator postfix_expression
49: postfix_expression ->  primary_expression
50: postfix_expression (IDENTIFIER) ->  IDENTIFIER '(' ')'
51: postfix_expression (IDENTIFIER) ->  IDENTIFIER '(' expression_list ')'
52: postfix_expression (INC_OP) ->  l_expression INC_OP
53: primary_expression ->  l_expression
54: primary_expression ('=') ->  l_expression '=' expression
55: primary_expression (INT_CONSTANT) ->  INT_CONSTANT
56: primary_expression (FLOAT_CONSTANT) ->  FLOAT_CONSTANT
57: primary_expression (STRING_LITERAL) ->  STRING_LITERAL
58: primary_expression ('(') ->  '(' expression ')'
59: l_expression (IDENTIFIER) ->  IDENTIFIER
60: l_expression ('[') ->  l_expression '[' expression ']'
61: expression_list ->  expression
62: expression_list (',') ->  expression_list ',' expression
63: unary_operator ('-') ->  '-'
64: unary_operator ('!') ->  '!'
65: selection_statement (IF) ->  IF '(' expression ')' statement ELSE statement
66: iteration_statement (WHILE) ->  WHILE '(' expression ')' statement
67: iteration_statement (FOR) ->  FOR '(' expression ';' expression ';' expression ')' statement
68: declaration_list ->  declaration
69: declaration_list ->  declaration_list declaration
70: declaration (';') ->  type_specifier declarator_list ';'
71: declarator_list ->  declarator
72: declarator_list (',') ->  declarator_list ',' declarator
73: translation_unit_$ ->  translation_unit

[parse.y (info)] 
Symbolic Terminal tokens:
       error
       EOF
   257: VOID
   258: INT
   259: FLOAT
   260: RETURN
   261: LE_OP
   262: GE_OP
   263: EQ_OP
   264: NE_OP
   265: OR_OP
   266: AND_OP
   267: INC_OP
   268: IF
   269: ELSE
   270: WHILE
   271: FOR
   272: INT_CONSTANT
   273: FLOAT_CONSTANT
   274: STRING_LITERAL
   275: IDENTIFIER
    40: '('
    41: ')'
    44: ','
    91: '['
    93: ']'
   123: '{'
   125: '}'
    59: ';'
    61: '='
    60: '<'
    62: '>'
    43: '+'
    45: '-'
    42: '*'
    47: '/'
    33: '!'

[parse.y (info)] 
FIRST sets:
   translation_unit: { VOID INT FLOAT }
   function_definition: { VOID INT FLOAT }
   type_specifier: { VOID INT FLOAT }
   fun_declarator: { IDENTIFIER }
   compound_statement: { '{' }
   parameter_list: { VOID INT FLOAT }
   parameter_declaration: { VOID INT FLOAT }
   declarator: { IDENTIFIER }
   constant_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL }
   statement_list: { RETURN IF WHILE FOR IDENTIFIER '{' ';' }
   declaration_list: { VOID INT FLOAT }
   statement: { RETURN IF WHILE FOR IDENTIFIER '{' ';' }
   selection_statement: { IF }
   iteration_statement: { WHILE FOR }
   assignment_statement: { IDENTIFIER ';' }
   expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   l_expression: { IDENTIFIER }
   logical_and_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   equality_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   relational_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   additive_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   multiplicative_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   unary_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   postfix_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }
   unary_operator: { '-' '!' }
   primary_expression: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }
   expression_list: { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' '-' '!' }
   declaration: { VOID INT FLOAT }
   declarator_list: { IDENTIFIER }
   translation_unit_$: { VOID INT FLOAT }

[parse.y (info)] 
Grammar States: 
[parse.y (info)] 
For each state information like the following is shown for its items:
   0: [P1 1] S -> C  . C   { <EOF> }  0
which should be read as follows:
   0:          The item's index
   [P1 1]:     The rule (production) number and current dot-position
   S -> C . C: The item (lhs -> Recognized-symbols . symbols-to-recognize)
   { <EOF> }   The item's lookahead (LA) set
   0           The next-element (shown below the items) describing the
               action associated with this item (-1 for reducible items)

The Next tables show entries like:
   0: On C to state 5 with (0 )
meaning:
   0:               The Next table's index
   On C to state 5: When C was recognized, continue at state 5
   with (0 )        The item(s) whose dot is shifted at the next state
Indices (like 0:) may be annotated as follows:
   0 (AUTO REMOVED by S/R resolution): On C ...
       in which case a reduction using a production with unspecified
       precedence took priority;
or:
   0 (removed by precedence): On C ...
       in which case a production rule's precedence took priority
Also, reduction item(s) may be listed


State 0:
0: [P73 0] translation_unit_$ ->  . translation_unit   { <EOF> }  0
1: [P1 0] translation_unit ->  . function_definition   { VOID INT FLOAT <EOF> }  1
2: [P2 0] translation_unit ->  . translation_unit function_definition   { VOID INT FLOAT <EOF> }  0
3: [P3 0] function_definition ->  . type_specifier fun_declarator compound_statement   { VOID INT FLOAT <EOF> }  2
4: [P4 0] type_specifier ->  . VOID   { IDENTIFIER }  3
5: [P5 0] type_specifier ->  . INT   { IDENTIFIER }  4
6: [P6 0] type_specifier ->  . FLOAT   { IDENTIFIER }  5
  0:   On translation_unit to state 1 with (0 2 )
  1:   On function_definition to state 2 with (1 )
  2:   On type_specifier to state 3 with (3 )
  3:   On VOID to state 4 with (4 )
  4:   On INT to state 5 with (5 )
  5:   On FLOAT to state 6 with (6 )


State 1:
0: [P73 1] translation_unit_$ -> translation_unit  .   { <EOF> }  -1
1: [P2 1] translation_unit -> translation_unit  . function_definition   { VOID INT FLOAT <EOF> }  0
2: [P3 0] function_definition ->  . type_specifier fun_declarator compound_statement   { VOID INT FLOAT <EOF> }  1
3: [P4 0] type_specifier ->  . VOID   { IDENTIFIER }  2
4: [P5 0] type_specifier ->  . INT   { IDENTIFIER }  3
5: [P6 0] type_specifier ->  . FLOAT   { IDENTIFIER }  4
  0:   On function_definition to state 7 with (1 )
  1:   On type_specifier to state 3 with (2 )
  2:   On VOID to state 4 with (3 )
  3:   On INT to state 5 with (4 )
  4:   On FLOAT to state 6 with (5 )


State 2:
0: [P1 1] translation_unit -> function_definition  .   { VOID INT FLOAT <EOF> }  -1
  Reduce item(s): 0 


State 3:
0: [P3 1] function_definition -> type_specifier  . fun_declarator compound_statement   { VOID INT FLOAT <EOF> }  0
1: [P7 0] fun_declarator ->  . IDENTIFIER '(' parameter_list ')'   { '{' }  1
2: [P8 0] fun_declarator ->  . IDENTIFIER '(' ')'   { '{' }  1
  0:   On fun_declarator to state 8 with (0 )
  1:   On IDENTIFIER to state 9 with (1 2 )


State 4:
0: [P4 1] type_specifier -> VOID  .   { IDENTIFIER }  -1
  Reduce item(s): 0 


State 5:
0: [P5 1] type_specifier -> INT  .   { IDENTIFIER }  -1
  Reduce item(s): 0 


State 6:
0: [P6 1] type_specifier -> FLOAT  .   { IDENTIFIER }  -1
  Reduce item(s): 0 


State 7:
0: [P2 2] translation_unit -> translation_unit function_definition  .   { VOID INT FLOAT <EOF> }  -1
  Reduce item(s): 0 


State 8:
0: [P3 2] function_definition -> type_specifier fun_declarator  . compound_statement   { VOID INT FLOAT <EOF> }  0
1: [P17 0] compound_statement ->  . '{' '}'   { VOID INT FLOAT <EOF> }  1
2: [P18 0] compound_statement ->  . '{' statement_list '}'   { VOID INT FLOAT <EOF> }  1
3: [P19 0] compound_statement ->  . '{' declaration_list statement_list '}'   { VOID INT FLOAT <EOF> }  1
  0:   On compound_statement to state 10 with (0 )
  1:   On '{' to state 11 with (1 2 3 )


State 9:
0: [P7 1] fun_declarator -> IDENTIFIER  . '(' parameter_list ')'   { '{' }  0
1: [P8 1] fun_declarator -> IDENTIFIER  . '(' ')'   { '{' }  0
  0:   On '(' to state 12 with (0 1 )


State 10:
0: [P3 3] function_definition -> type_specifier fun_declarator compound_statement  .   { VOID INT FLOAT <EOF> }  -1
  Reduce item(s): 0 


State 11:
0: [P17 1] compound_statement -> '{'  . '}'   { VOID INT FLOAT <EOF> }  0
1: [P18 1] compound_statement -> '{'  . statement_list '}'   { VOID INT FLOAT <EOF> }  1
2: [P19 1] compound_statement -> '{'  . declaration_list statement_list '}'   { VOID INT FLOAT <EOF> }  2
3: [P20 0] statement_list ->  . statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  3
4: [P21 0] statement_list ->  . statement_list statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  1
5: [P68 0] declaration_list ->  . declaration   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  4
6: [P69 0] declaration_list ->  . declaration_list declaration   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  2
7: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  5
8: [P23 0] statement ->  . selection_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  6
9: [P24 0] statement ->  . iteration_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  7
10: [P25 0] statement ->  . assignment_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  8
11: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  9
12: [P70 0] declaration ->  . type_specifier declarator_list ';'   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  10
13: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  11
14: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  12
15: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  13
16: [P27 0] assignment_statement ->  . ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  14
17: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  15
18: [P4 0] type_specifier ->  . VOID   { IDENTIFIER }  16
19: [P5 0] type_specifier ->  . INT   { IDENTIFIER }  17
20: [P6 0] type_specifier ->  . FLOAT   { IDENTIFIER }  18
21: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  19
22: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  15
  0:   On '}' to state 13 with (0 )
  1:   On statement_list to state 14 with (1 4 )
  2:   On declaration_list to state 15 with (2 6 )
  3:   On statement to state 16 with (3 )
  4:   On declaration to state 17 with (5 )
  5:   On '{' to state 18 with (7 )
  6:   On selection_statement to state 19 with (8 )
  7:   On iteration_statement to state 20 with (9 )
  8:   On assignment_statement to state 21 with (10 )
  9:   On RETURN to state 22 with (11 )
  10:   On type_specifier to state 23 with (12 )
  11:   On IF to state 24 with (13 )
  12:   On WHILE to state 25 with (14 )
  13:   On FOR to state 26 with (15 )
  14:   On ';' to state 27 with (16 )
  15:   On l_expression to state 28 with (17 22 )
  16:   On VOID to state 4 with (18 )
  17:   On INT to state 5 with (19 )
  18:   On FLOAT to state 6 with (20 )
  19:   On IDENTIFIER to state 29 with (21 )


State 12:
0: [P7 2] fun_declarator -> IDENTIFIER '('  . parameter_list ')'   { '{' }  0
1: [P8 2] fun_declarator -> IDENTIFIER '('  . ')'   { '{' }  1
2: [P9 0] parameter_list ->  . parameter_declaration   { ')' ',' }  2
3: [P10 0] parameter_list ->  . parameter_list ',' parameter_declaration   { ')' ',' }  0
4: [P11 0] parameter_declaration ->  . type_specifier declarator   { ')' ',' }  3
5: [P4 0] type_specifier ->  . VOID   { IDENTIFIER }  4
6: [P5 0] type_specifier ->  . INT   { IDENTIFIER }  5
7: [P6 0] type_specifier ->  . FLOAT   { IDENTIFIER }  6
  0:   On parameter_list to state 30 with (0 3 )
  1:   On ')' to state 31 with (1 )
  2:   On parameter_declaration to state 32 with (2 )
  3:   On type_specifier to state 33 with (4 )
  4:   On VOID to state 4 with (5 )
  5:   On INT to state 5 with (6 )
  6:   On FLOAT to state 6 with (7 )


State 13:
0: [P17 2] compound_statement -> '{' '}'  .   { VOID INT FLOAT <EOF> }  -1
  Reduce item(s): 0 


State 14:
0: [P18 2] compound_statement -> '{' statement_list  . '}'   { VOID INT FLOAT <EOF> }  0
1: [P21 1] statement_list -> statement_list  . statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  1
2: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  2
3: [P23 0] statement ->  . selection_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  3
4: [P24 0] statement ->  . iteration_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  4
5: [P25 0] statement ->  . assignment_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  5
6: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  6
7: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  7
8: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  8
9: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  9
10: [P27 0] assignment_statement ->  . ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  10
11: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  11
12: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  12
13: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  11
  0:   On '}' to state 34 with (0 )
  1:   On statement to state 35 with (1 )
  2:   On '{' to state 18 with (2 )
  3:   On selection_statement to state 19 with (3 )
  4:   On iteration_statement to state 20 with (4 )
  5:   On assignment_statement to state 21 with (5 )
  6:   On RETURN to state 22 with (6 )
  7:   On IF to state 24 with (7 )
  8:   On WHILE to state 25 with (8 )
  9:   On FOR to state 26 with (9 )
  10:   On ';' to state 27 with (10 )
  11:   On l_expression to state 28 with (11 13 )
  12:   On IDENTIFIER to state 29 with (12 )


State 15:
0: [P19 2] compound_statement -> '{' declaration_list  . statement_list '}'   { VOID INT FLOAT <EOF> }  0
1: [P69 1] declaration_list -> declaration_list  . declaration   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  1
2: [P20 0] statement_list ->  . statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  2
3: [P21 0] statement_list ->  . statement_list statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  0
4: [P70 0] declaration ->  . type_specifier declarator_list ';'   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  3
5: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  4
6: [P23 0] statement ->  . selection_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  5
7: [P24 0] statement ->  . iteration_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  6
8: [P25 0] statement ->  . assignment_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  7
9: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  8
10: [P4 0] type_specifier ->  . VOID   { IDENTIFIER }  9
11: [P5 0] type_specifier ->  . INT   { IDENTIFIER }  10
12: [P6 0] type_specifier ->  . FLOAT   { IDENTIFIER }  11
13: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  12
14: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  13
15: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  14
16: [P27 0] assignment_statement ->  . ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  15
17: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  16
18: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  17
19: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  16
  0:   On statement_list to state 36 with (0 3 )
  1:   On declaration to state 37 with (1 )
  2:   On statement to state 16 with (2 )
  3:   On type_specifier to state 23 with (4 )
  4:   On '{' to state 18 with (5 )
  5:   On selection_statement to state 19 with (6 )
  6:   On iteration_statement to state 20 with (7 )
  7:   On assignment_statement to state 21 with (8 )
  8:   On RETURN to state 22 with (9 )
  9:   On VOID to state 4 with (10 )
  10:   On INT to state 5 with (11 )
  11:   On FLOAT to state 6 with (12 )
  12:   On IF to state 24 with (13 )
  13:   On WHILE to state 25 with (14 )
  14:   On FOR to state 26 with (15 )
  15:   On ';' to state 27 with (16 )
  16:   On l_expression to state 28 with (17 19 )
  17:   On IDENTIFIER to state 29 with (18 )


State 16:
0: [P20 1] statement_list -> statement  .   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 17:
0: [P68 1] declaration_list -> declaration  .   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  -1
  Reduce item(s): 0 


State 18:
0: [P22 1] statement -> '{'  . statement_list '}'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P20 0] statement_list ->  . statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  1
2: [P21 0] statement_list ->  . statement_list statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  0
3: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  2
4: [P23 0] statement ->  . selection_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  3
5: [P24 0] statement ->  . iteration_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  4
6: [P25 0] statement ->  . assignment_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  5
7: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  6
8: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  7
9: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  8
10: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  9
11: [P27 0] assignment_statement ->  . ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  10
12: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  11
13: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  12
14: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  11
  0:   On statement_list to state 38 with (0 2 )
  1:   On statement to state 16 with (1 )
  2:   On '{' to state 18 with (3 )
  3:   On selection_statement to state 19 with (4 )
  4:   On iteration_statement to state 20 with (5 )
  5:   On assignment_statement to state 21 with (6 )
  6:   On RETURN to state 22 with (7 )
  7:   On IF to state 24 with (8 )
  8:   On WHILE to state 25 with (9 )
  9:   On FOR to state 26 with (10 )
  10:   On ';' to state 27 with (11 )
  11:   On l_expression to state 28 with (12 14 )
  12:   On IDENTIFIER to state 29 with (13 )


State 19:
0: [P23 1] statement -> selection_statement  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 20:
0: [P24 1] statement -> iteration_statement  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 21:
0: [P25 1] statement -> assignment_statement  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 22:
0: [P26 1] statement -> RETURN  . expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ';' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ';' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ';' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ';' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 39 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 23:
0: [P70 1] declaration -> type_specifier  . declarator_list ';'   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  0
1: [P71 0] declarator_list ->  . declarator   { ',' ';' }  1
2: [P72 0] declarator_list ->  . declarator_list ',' declarator   { ',' ';' }  0
3: [P12 0] declarator ->  . IDENTIFIER   { ',' '[' ';' }  2
4: [P13 0] declarator ->  . declarator '[' constant_expression ']'   { ',' '[' ';' }  1
  0:   On declarator_list to state 57 with (0 2 )
  1:   On declarator to state 58 with (1 4 )
  2:   On IDENTIFIER to state 59 with (3 )


State 24:
0: [P65 1] selection_statement -> IF  . '(' expression ')' statement ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
  0:   On '(' to state 60 with (0 )


State 25:
0: [P66 1] iteration_statement -> WHILE  . '(' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
  0:   On '(' to state 61 with (0 )


State 26:
0: [P67 1] iteration_statement -> FOR  . '(' expression ';' expression ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
  0:   On '(' to state 62 with (0 )


State 27:
0: [P27 1] assignment_statement -> ';'  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 28:
0: [P28 1] assignment_statement -> l_expression  . '=' expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P60 1] l_expression -> l_expression  . '[' expression ']'   { '[' '=' }  1
  0:   On '=' to state 63 with (0 )
  1:   On '[' to state 64 with (1 )


State 29:
0: [P59 1] l_expression -> IDENTIFIER  .   { '[' '=' }  -1
  Reduce item(s): 0 


State 30:
0: [P7 3] fun_declarator -> IDENTIFIER '(' parameter_list  . ')'   { '{' }  0
1: [P10 1] parameter_list -> parameter_list  . ',' parameter_declaration   { ')' ',' }  1
  0:   On ')' to state 65 with (0 )
  1:   On ',' to state 66 with (1 )


State 31:
0: [P8 3] fun_declarator -> IDENTIFIER '(' ')'  .   { '{' }  -1
  Reduce item(s): 0 


State 32:
0: [P9 1] parameter_list -> parameter_declaration  .   { ')' ',' }  -1
  Reduce item(s): 0 


State 33:
0: [P11 1] parameter_declaration -> type_specifier  . declarator   { ')' ',' }  0
1: [P12 0] declarator ->  . IDENTIFIER   { ')' ',' '[' }  1
2: [P13 0] declarator ->  . declarator '[' constant_expression ']'   { ')' ',' '[' }  0
  0:   On declarator to state 67 with (0 2 )
  1:   On IDENTIFIER to state 59 with (1 )


State 34:
0: [P18 3] compound_statement -> '{' statement_list '}'  .   { VOID INT FLOAT <EOF> }  -1
  Reduce item(s): 0 


State 35:
0: [P21 2] statement_list -> statement_list statement  .   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 36:
0: [P19 3] compound_statement -> '{' declaration_list statement_list  . '}'   { VOID INT FLOAT <EOF> }  0
1: [P21 1] statement_list -> statement_list  . statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  1
2: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  2
3: [P23 0] statement ->  . selection_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  3
4: [P24 0] statement ->  . iteration_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  4
5: [P25 0] statement ->  . assignment_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  5
6: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  6
7: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  7
8: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  8
9: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  9
10: [P27 0] assignment_statement ->  . ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  10
11: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  11
12: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  12
13: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  11
  0:   On '}' to state 68 with (0 )
  1:   On statement to state 35 with (1 )
  2:   On '{' to state 18 with (2 )
  3:   On selection_statement to state 19 with (3 )
  4:   On iteration_statement to state 20 with (4 )
  5:   On assignment_statement to state 21 with (5 )
  6:   On RETURN to state 22 with (6 )
  7:   On IF to state 24 with (7 )
  8:   On WHILE to state 25 with (8 )
  9:   On FOR to state 26 with (9 )
  10:   On ';' to state 27 with (10 )
  11:   On l_expression to state 28 with (11 13 )
  12:   On IDENTIFIER to state 29 with (12 )


State 37:
0: [P69 2] declaration_list -> declaration_list declaration  .   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  -1
  Reduce item(s): 0 


State 38:
0: [P22 2] statement -> '{' statement_list  . '}'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P21 1] statement_list -> statement_list  . statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  1
2: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  2
3: [P23 0] statement ->  . selection_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  3
4: [P24 0] statement ->  . iteration_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  4
5: [P25 0] statement ->  . assignment_statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  5
6: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  6
7: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  7
8: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  8
9: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  9
10: [P27 0] assignment_statement ->  . ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  10
11: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF WHILE FOR IDENTIFIER '{' '}' ';' }  11
12: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  12
13: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  11
  0:   On '}' to state 69 with (0 )
  1:   On statement to state 35 with (1 )
  2:   On '{' to state 18 with (2 )
  3:   On selection_statement to state 19 with (3 )
  4:   On iteration_statement to state 20 with (4 )
  5:   On assignment_statement to state 21 with (5 )
  6:   On RETURN to state 22 with (6 )
  7:   On IF to state 24 with (7 )
  8:   On WHILE to state 25 with (8 )
  9:   On FOR to state 26 with (9 )
  10:   On ';' to state 27 with (10 )
  11:   On l_expression to state 28 with (11 13 )
  12:   On IDENTIFIER to state 29 with (12 )


State 39:
0: [P26 2] statement -> RETURN expression  . ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ';' }  1
  0:   On ';' to state 70 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 40:
0: [P29 1] expression -> logical_and_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
1: [P32 1] logical_and_expression -> logical_and_expression  . AND_OP equality_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
  0:   On AND_OP to state 72 with (1 )
  Reduce item(s): 0 
Solved SR CONFLICT on AND_OP:
	shift to state 72, removed AND_OP from LA-set of rule 29)


State 41:
0: [P31 1] logical_and_expression -> equality_expression  .   { LE_OP GE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
1: [P34 1] equality_expression -> equality_expression  . EQ_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P35 1] equality_expression -> equality_expression  . NE_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On EQ_OP to state 73 with (1 )
  1:   On NE_OP to state 74 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on EQ_OP:
	shift to state 73, removed EQ_OP from LA-set of rule 31)
Solved SR CONFLICT on NE_OP:
	shift to state 74, removed NE_OP from LA-set of rule 31)


State 42:
0: [P33 1] equality_expression -> relational_expression  .   { EQ_OP NE_OP OR_OP AND_OP ')' ',' ']' ';' '+' '-' '*' '/' }  -1
1: [P37 1] relational_expression -> relational_expression  . '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P38 1] relational_expression -> relational_expression  . '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
3: [P39 1] relational_expression -> relational_expression  . LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
4: [P40 1] relational_expression -> relational_expression  . GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
  0:   On '<' to state 75 with (1 )
  1:   On '>' to state 76 with (2 )
  2:   On LE_OP to state 77 with (3 )
  3:   On GE_OP to state 78 with (4 )
  Reduce item(s): 0 
Solved SR CONFLICT on '<':
	shift to state 75, removed '<' from LA-set of rule 33)
Solved SR CONFLICT on '>':
	shift to state 76, removed '>' from LA-set of rule 33)
Solved SR CONFLICT on LE_OP:
	shift to state 77, removed LE_OP from LA-set of rule 33)
Solved SR CONFLICT on GE_OP:
	shift to state 78, removed GE_OP from LA-set of rule 33)


State 43:
0: [P36 1] relational_expression -> additive_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '*' '/' }  -1
1: [P42 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P43 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '+' to state 79 with (1 )
  1:   On '-' to state 80 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '+':
	shift to state 79, removed '+' from LA-set of rule 36)
Solved SR CONFLICT on '-':
	shift to state 80, removed '-' from LA-set of rule 36)


State 44:
0: [P41 1] additive_expression -> multiplicative_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' }  -1
1: [P45 1] multiplicative_expression -> multiplicative_expression  . '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P46 1] multiplicative_expression -> multiplicative_expression  . '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '*' to state 81 with (1 )
  1:   On '/' to state 82 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '*':
	shift to state 81, removed '*' from LA-set of rule 41)
Solved SR CONFLICT on '/':
	shift to state 82, removed '/' from LA-set of rule 41)


State 45:
0: [P44 1] multiplicative_expression -> unary_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 46:
0: [P47 1] unary_expression -> postfix_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 47:
0: [P48 1] unary_expression -> unary_operator  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
3: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
4: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
5: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
6: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
7: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
8: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
9: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
10: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
11: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  2
12: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  3
  0:   On postfix_expression to state 83 with (0 )
  1:   On primary_expression to state 48 with (1 )
  2:   On IDENTIFIER to state 49 with (2 3 11 )
  3:   On l_expression to state 50 with (4 5 6 12 )
  4:   On INT_CONSTANT to state 53 with (7 )
  5:   On FLOAT_CONSTANT to state 54 with (8 )
  6:   On STRING_LITERAL to state 55 with (9 )
  7:   On '(' to state 56 with (10 )


State 48:
0: [P49 1] postfix_expression -> primary_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 49:
0: [P50 1] postfix_expression -> IDENTIFIER  . '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P51 1] postfix_expression -> IDENTIFIER  . '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P59 1] l_expression -> IDENTIFIER  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  -1
  0:   On '(' to state 84 with (0 1 )
  Reduce item(s): 2 


State 50:
0: [P52 1] postfix_expression -> l_expression  . INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P53 1] primary_expression -> l_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
2: [P54 1] primary_expression -> l_expression  . '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
3: [P60 1] l_expression -> l_expression  . '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  2
  0:   On INC_OP to state 85 with (0 )
  1:   On '=' to state 86 with (2 )
  2:   On '[' to state 64 with (3 )
  Reduce item(s): 1 


State 51:
0: [P63 1] unary_operator -> '-'  .   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  -1
  Reduce item(s): 0 


State 52:
0: [P64 1] unary_operator -> '!'  .   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  -1
  Reduce item(s): 0 


State 53:
0: [P55 1] primary_expression -> INT_CONSTANT  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 54:
0: [P56 1] primary_expression -> FLOAT_CONSTANT  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 55:
0: [P57 1] primary_expression -> STRING_LITERAL  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 56:
0: [P58 1] primary_expression -> '('  . expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ')' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ')' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ')' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ')' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 87 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 57:
0: [P70 2] declaration -> type_specifier declarator_list  . ';'   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  0
1: [P72 1] declarator_list -> declarator_list  . ',' declarator   { ',' ';' }  1
  0:   On ';' to state 88 with (0 )
  1:   On ',' to state 89 with (1 )


State 58:
0: [P71 1] declarator_list -> declarator  .   { ',' ';' }  -1
1: [P13 1] declarator -> declarator  . '[' constant_expression ']'   { ',' '[' ';' }  0
  0:   On '[' to state 90 with (1 )
  Reduce item(s): 0 


State 59:
0: [P12 1] declarator -> IDENTIFIER  .   { ')' ',' '[' ';' }  -1
  Reduce item(s): 0 


State 60:
0: [P65 2] selection_statement -> IF '('  . expression ')' statement ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ')' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ')' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ')' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ')' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 91 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 61:
0: [P66 2] iteration_statement -> WHILE '('  . expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ')' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ')' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ')' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ')' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 92 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 62:
0: [P67 2] iteration_statement -> FOR '('  . expression ';' expression ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ';' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ';' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ';' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ';' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 93 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 63:
0: [P28 2] assignment_statement -> l_expression '='  . expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ';' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ';' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ';' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ';' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 94 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 64:
0: [P60 2] l_expression -> l_expression '['  . expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ']' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ']' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ']' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ']' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ']' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ']' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ']' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ']' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ']' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ']' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 95 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 65:
0: [P7 4] fun_declarator -> IDENTIFIER '(' parameter_list ')'  .   { '{' }  -1
  Reduce item(s): 0 


State 66:
0: [P10 2] parameter_list -> parameter_list ','  . parameter_declaration   { ')' ',' }  0
1: [P11 0] parameter_declaration ->  . type_specifier declarator   { ')' ',' }  1
2: [P4 0] type_specifier ->  . VOID   { IDENTIFIER }  2
3: [P5 0] type_specifier ->  . INT   { IDENTIFIER }  3
4: [P6 0] type_specifier ->  . FLOAT   { IDENTIFIER }  4
  0:   On parameter_declaration to state 96 with (0 )
  1:   On type_specifier to state 33 with (1 )
  2:   On VOID to state 4 with (2 )
  3:   On INT to state 5 with (3 )
  4:   On FLOAT to state 6 with (4 )


State 67:
0: [P11 2] parameter_declaration -> type_specifier declarator  .   { ')' ',' }  -1
1: [P13 1] declarator -> declarator  . '[' constant_expression ']'   { ')' ',' '[' }  0
  0:   On '[' to state 90 with (1 )
  Reduce item(s): 0 


State 68:
0: [P19 4] compound_statement -> '{' declaration_list statement_list '}'  .   { VOID INT FLOAT <EOF> }  -1
  Reduce item(s): 0 


State 69:
0: [P22 3] statement -> '{' statement_list '}'  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 70:
0: [P26 3] statement -> RETURN expression ';'  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 71:
0: [P30 2] expression -> expression OR_OP  . logical_and_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P31 0] logical_and_expression ->  . equality_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P33 0] equality_expression ->  . relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
4: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
5: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
6: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
7: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
8: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
9: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
10: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
11: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
12: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
13: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
14: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
15: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
16: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
17: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
18: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
19: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
20: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
21: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
22: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
23: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  11
24: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
25: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
26: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
27: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
28: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  14
29: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  15
30: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  16
31: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  9
32: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  10
  0:   On logical_and_expression to state 97 with (0 2 )
  1:   On equality_expression to state 41 with (1 4 5 )
  2:   On relational_expression to state 42 with (3 7 8 9 10 )
  3:   On additive_expression to state 43 with (6 12 13 )
  4:   On multiplicative_expression to state 44 with (11 15 16 )
  5:   On unary_expression to state 45 with (14 )
  6:   On postfix_expression to state 46 with (17 )
  7:   On unary_operator to state 47 with (18 )
  8:   On primary_expression to state 48 with (19 )
  9:   On IDENTIFIER to state 49 with (20 21 31 )
  10:   On l_expression to state 50 with (22 25 26 32 )
  11:   On '-' to state 51 with (23 )
  12:   On '!' to state 52 with (24 )
  13:   On INT_CONSTANT to state 53 with (27 )
  14:   On FLOAT_CONSTANT to state 54 with (28 )
  15:   On STRING_LITERAL to state 55 with (29 )
  16:   On '(' to state 56 with (30 )


State 72:
0: [P32 2] logical_and_expression -> logical_and_expression AND_OP  . equality_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P33 0] equality_expression ->  . relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
5: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
6: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
7: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
8: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
9: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
10: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
11: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
12: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
13: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
14: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
15: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
16: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
17: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
18: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
19: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
20: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
21: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  10
22: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  11
23: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
24: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
25: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
26: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
27: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  14
28: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  15
29: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  8
30: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  9
  0:   On equality_expression to state 98 with (0 2 3 )
  1:   On relational_expression to state 42 with (1 5 6 7 8 )
  2:   On additive_expression to state 43 with (4 10 11 )
  3:   On multiplicative_expression to state 44 with (9 13 14 )
  4:   On unary_expression to state 45 with (12 )
  5:   On postfix_expression to state 46 with (15 )
  6:   On unary_operator to state 47 with (16 )
  7:   On primary_expression to state 48 with (17 )
  8:   On IDENTIFIER to state 49 with (18 19 29 )
  9:   On l_expression to state 50 with (20 23 24 30 )
  10:   On '-' to state 51 with (21 )
  11:   On '!' to state 52 with (22 )
  12:   On INT_CONSTANT to state 53 with (25 )
  13:   On FLOAT_CONSTANT to state 54 with (26 )
  14:   On STRING_LITERAL to state 55 with (27 )
  15:   On '(' to state 56 with (28 )


State 73:
0: [P34 2] equality_expression -> equality_expression EQ_OP  . relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
5: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
6: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
7: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
8: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
9: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
10: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
11: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
12: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
13: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
14: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
15: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
16: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
17: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
18: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  9
19: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  10
20: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
21: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
22: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
23: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
24: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
25: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  14
26: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  7
27: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  8
  0:   On relational_expression to state 99 with (0 2 3 4 5 )
  1:   On additive_expression to state 43 with (1 7 8 )
  2:   On multiplicative_expression to state 44 with (6 10 11 )
  3:   On unary_expression to state 45 with (9 )
  4:   On postfix_expression to state 46 with (12 )
  5:   On unary_operator to state 47 with (13 )
  6:   On primary_expression to state 48 with (14 )
  7:   On IDENTIFIER to state 49 with (15 16 26 )
  8:   On l_expression to state 50 with (17 20 21 27 )
  9:   On '-' to state 51 with (18 )
  10:   On '!' to state 52 with (19 )
  11:   On INT_CONSTANT to state 53 with (22 )
  12:   On FLOAT_CONSTANT to state 54 with (23 )
  13:   On STRING_LITERAL to state 55 with (24 )
  14:   On '(' to state 56 with (25 )


State 74:
0: [P35 2] equality_expression -> equality_expression NE_OP  . relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
5: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
6: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
7: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
8: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
9: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
10: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
11: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
12: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
13: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
14: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
15: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
16: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
17: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
18: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  9
19: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  10
20: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
21: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
22: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
23: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
24: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
25: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  14
26: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  7
27: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  8
  0:   On relational_expression to state 100 with (0 2 3 4 5 )
  1:   On additive_expression to state 43 with (1 7 8 )
  2:   On multiplicative_expression to state 44 with (6 10 11 )
  3:   On unary_expression to state 45 with (9 )
  4:   On postfix_expression to state 46 with (12 )
  5:   On unary_operator to state 47 with (13 )
  6:   On primary_expression to state 48 with (14 )
  7:   On IDENTIFIER to state 49 with (15 16 26 )
  8:   On l_expression to state 50 with (17 20 21 27 )
  9:   On '-' to state 51 with (18 )
  10:   On '!' to state 52 with (19 )
  11:   On INT_CONSTANT to state 53 with (22 )
  12:   On FLOAT_CONSTANT to state 54 with (23 )
  13:   On STRING_LITERAL to state 55 with (24 )
  14:   On '(' to state 56 with (25 )


State 75:
0: [P37 2] relational_expression -> relational_expression '<'  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
5: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
6: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
7: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
8: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
9: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
10: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
11: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
12: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
13: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  8
14: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  9
15: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
16: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
17: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
18: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
19: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
20: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
21: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  6
22: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  7
  0:   On additive_expression to state 101 with (0 2 3 )
  1:   On multiplicative_expression to state 44 with (1 5 6 )
  2:   On unary_expression to state 45 with (4 )
  3:   On postfix_expression to state 46 with (7 )
  4:   On unary_operator to state 47 with (8 )
  5:   On primary_expression to state 48 with (9 )
  6:   On IDENTIFIER to state 49 with (10 11 21 )
  7:   On l_expression to state 50 with (12 15 16 22 )
  8:   On '-' to state 51 with (13 )
  9:   On '!' to state 52 with (14 )
  10:   On INT_CONSTANT to state 53 with (17 )
  11:   On FLOAT_CONSTANT to state 54 with (18 )
  12:   On STRING_LITERAL to state 55 with (19 )
  13:   On '(' to state 56 with (20 )


State 76:
0: [P38 2] relational_expression -> relational_expression '>'  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
5: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
6: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
7: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
8: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
9: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
10: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
11: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
12: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
13: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  8
14: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  9
15: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
16: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
17: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
18: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
19: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
20: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
21: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  6
22: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  7
  0:   On additive_expression to state 102 with (0 2 3 )
  1:   On multiplicative_expression to state 44 with (1 5 6 )
  2:   On unary_expression to state 45 with (4 )
  3:   On postfix_expression to state 46 with (7 )
  4:   On unary_operator to state 47 with (8 )
  5:   On primary_expression to state 48 with (9 )
  6:   On IDENTIFIER to state 49 with (10 11 21 )
  7:   On l_expression to state 50 with (12 15 16 22 )
  8:   On '-' to state 51 with (13 )
  9:   On '!' to state 52 with (14 )
  10:   On INT_CONSTANT to state 53 with (17 )
  11:   On FLOAT_CONSTANT to state 54 with (18 )
  12:   On STRING_LITERAL to state 55 with (19 )
  13:   On '(' to state 56 with (20 )


State 77:
0: [P39 2] relational_expression -> relational_expression LE_OP  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
5: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
6: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
7: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
8: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
9: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
10: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
11: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
12: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
13: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  8
14: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  9
15: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
16: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
17: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
18: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
19: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
20: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
21: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  6
22: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  7
  0:   On additive_expression to state 103 with (0 2 3 )
  1:   On multiplicative_expression to state 44 with (1 5 6 )
  2:   On unary_expression to state 45 with (4 )
  3:   On postfix_expression to state 46 with (7 )
  4:   On unary_operator to state 47 with (8 )
  5:   On primary_expression to state 48 with (9 )
  6:   On IDENTIFIER to state 49 with (10 11 21 )
  7:   On l_expression to state 50 with (12 15 16 22 )
  8:   On '-' to state 51 with (13 )
  9:   On '!' to state 52 with (14 )
  10:   On INT_CONSTANT to state 53 with (17 )
  11:   On FLOAT_CONSTANT to state 54 with (18 )
  12:   On STRING_LITERAL to state 55 with (19 )
  13:   On '(' to state 56 with (20 )


State 78:
0: [P40 2] relational_expression -> relational_expression GE_OP  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
5: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
6: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
7: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
8: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
9: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
10: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
11: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
12: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
13: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  8
14: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  9
15: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
16: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
17: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
18: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
19: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
20: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  13
21: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  6
22: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  7
  0:   On additive_expression to state 104 with (0 2 3 )
  1:   On multiplicative_expression to state 44 with (1 5 6 )
  2:   On unary_expression to state 45 with (4 )
  3:   On postfix_expression to state 46 with (7 )
  4:   On unary_operator to state 47 with (8 )
  5:   On primary_expression to state 48 with (9 )
  6:   On IDENTIFIER to state 49 with (10 11 21 )
  7:   On l_expression to state 50 with (12 15 16 22 )
  8:   On '-' to state 51 with (13 )
  9:   On '!' to state 52 with (14 )
  10:   On INT_CONSTANT to state 53 with (17 )
  11:   On FLOAT_CONSTANT to state 54 with (18 )
  12:   On STRING_LITERAL to state 55 with (19 )
  13:   On '(' to state 56 with (20 )


State 79:
0: [P42 2] additive_expression -> additive_expression '+'  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
5: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
6: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
7: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
8: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
9: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
10: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  7
11: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  8
12: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
13: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
14: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
15: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
16: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
17: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
18: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  5
19: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  6
  0:   On multiplicative_expression to state 105 with (0 2 3 )
  1:   On unary_expression to state 45 with (1 )
  2:   On postfix_expression to state 46 with (4 )
  3:   On unary_operator to state 47 with (5 )
  4:   On primary_expression to state 48 with (6 )
  5:   On IDENTIFIER to state 49 with (7 8 18 )
  6:   On l_expression to state 50 with (9 12 13 19 )
  7:   On '-' to state 51 with (10 )
  8:   On '!' to state 52 with (11 )
  9:   On INT_CONSTANT to state 53 with (14 )
  10:   On FLOAT_CONSTANT to state 54 with (15 )
  11:   On STRING_LITERAL to state 55 with (16 )
  12:   On '(' to state 56 with (17 )


State 80:
0: [P43 2] additive_expression -> additive_expression '-'  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
4: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
5: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
6: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
7: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
8: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
9: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
10: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  7
11: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  8
12: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
13: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
14: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
15: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
16: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
17: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  12
18: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  5
19: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  6
  0:   On multiplicative_expression to state 106 with (0 2 3 )
  1:   On unary_expression to state 45 with (1 )
  2:   On postfix_expression to state 46 with (4 )
  3:   On unary_operator to state 47 with (5 )
  4:   On primary_expression to state 48 with (6 )
  5:   On IDENTIFIER to state 49 with (7 8 18 )
  6:   On l_expression to state 50 with (9 12 13 19 )
  7:   On '-' to state 51 with (10 )
  8:   On '!' to state 52 with (11 )
  9:   On INT_CONSTANT to state 53 with (14 )
  10:   On FLOAT_CONSTANT to state 54 with (15 )
  11:   On STRING_LITERAL to state 55 with (16 )
  12:   On '(' to state 56 with (17 )


State 81:
0: [P45 2] multiplicative_expression -> multiplicative_expression '*'  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
3: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
4: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
5: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
6: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
7: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  6
8: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  7
9: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
10: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
11: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
12: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
13: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
14: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
15: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  4
16: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  5
  0:   On unary_expression to state 107 with (0 )
  1:   On postfix_expression to state 46 with (1 )
  2:   On unary_operator to state 47 with (2 )
  3:   On primary_expression to state 48 with (3 )
  4:   On IDENTIFIER to state 49 with (4 5 15 )
  5:   On l_expression to state 50 with (6 9 10 16 )
  6:   On '-' to state 51 with (7 )
  7:   On '!' to state 52 with (8 )
  8:   On INT_CONSTANT to state 53 with (11 )
  9:   On FLOAT_CONSTANT to state 54 with (12 )
  10:   On STRING_LITERAL to state 55 with (13 )
  11:   On '(' to state 56 with (14 )


State 82:
0: [P46 2] multiplicative_expression -> multiplicative_expression '/'  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
3: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
4: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
5: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
6: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
7: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  6
8: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  7
9: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
10: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
11: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
12: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
13: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
14: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
15: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  4
16: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  5
  0:   On unary_expression to state 108 with (0 )
  1:   On postfix_expression to state 46 with (1 )
  2:   On unary_operator to state 47 with (2 )
  3:   On primary_expression to state 48 with (3 )
  4:   On IDENTIFIER to state 49 with (4 5 15 )
  5:   On l_expression to state 50 with (6 9 10 16 )
  6:   On '-' to state 51 with (7 )
  7:   On '!' to state 52 with (8 )
  8:   On INT_CONSTANT to state 53 with (11 )
  9:   On FLOAT_CONSTANT to state 54 with (12 )
  10:   On STRING_LITERAL to state 55 with (13 )
  11:   On '(' to state 56 with (14 )


State 83:
0: [P48 2] unary_expression -> unary_operator postfix_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 84:
0: [P50 2] postfix_expression -> IDENTIFIER '('  . ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P51 2] postfix_expression -> IDENTIFIER '('  . expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P61 0] expression_list ->  . expression   { ')' ',' }  2
3: [P62 0] expression_list ->  . expression_list ',' expression   { ')' ',' }  1
4: [P29 0] expression ->  . logical_and_expression   { OR_OP ')' ',' }  3
5: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ')' ',' }  2
6: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ')' ',' }  4
7: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ')' ',' }  3
8: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' ',' }  5
9: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' ',' }  4
10: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' ',' }  4
11: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  6
12: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  5
13: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  5
14: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  5
15: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  5
16: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' }  7
17: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' }  6
18: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' }  6
19: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  8
20: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  7
21: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  7
22: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  9
23: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  10
24: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  11
25: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  12
26: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  12
27: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  13
28: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  14
29: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  15
30: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  13
31: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  13
32: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  16
33: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  17
34: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  18
35: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  19
36: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' '=' '>' '+' '-' '*' '/' }  12
37: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' '=' '>' '+' '-' '*' '/' }  13
  0:   On ')' to state 109 with (0 )
  1:   On expression_list to state 110 with (1 3 )
  2:   On expression to state 111 with (2 5 )
  3:   On logical_and_expression to state 40 with (4 7 )
  4:   On equality_expression to state 41 with (6 9 10 )
  5:   On relational_expression to state 42 with (8 12 13 14 15 )
  6:   On additive_expression to state 43 with (11 17 18 )
  7:   On multiplicative_expression to state 44 with (16 20 21 )
  8:   On unary_expression to state 45 with (19 )
  9:   On postfix_expression to state 46 with (22 )
  10:   On unary_operator to state 47 with (23 )
  11:   On primary_expression to state 48 with (24 )
  12:   On IDENTIFIER to state 49 with (25 26 36 )
  13:   On l_expression to state 50 with (27 30 31 37 )
  14:   On '-' to state 51 with (28 )
  15:   On '!' to state 52 with (29 )
  16:   On INT_CONSTANT to state 53 with (32 )
  17:   On FLOAT_CONSTANT to state 54 with (33 )
  18:   On STRING_LITERAL to state 55 with (34 )
  19:   On '(' to state 56 with (35 )


State 85:
0: [P52 2] postfix_expression -> l_expression INC_OP  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 86:
0: [P54 2] primary_expression -> l_expression '='  . expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P29 0] expression ->  . logical_and_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
5: [P33 0] equality_expression ->  . relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 112 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 87:
0: [P58 2] primary_expression -> '(' expression  . ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ')' }  1
  0:   On ')' to state 113 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 88:
0: [P70 3] declaration -> type_specifier declarator_list ';'  .   { VOID INT FLOAT RETURN IF WHILE FOR IDENTIFIER '{' ';' }  -1
  Reduce item(s): 0 


State 89:
0: [P72 2] declarator_list -> declarator_list ','  . declarator   { ',' ';' }  0
1: [P12 0] declarator ->  . IDENTIFIER   { ',' '[' ';' }  1
2: [P13 0] declarator ->  . declarator '[' constant_expression ']'   { ',' '[' ';' }  0
  0:   On declarator to state 114 with (0 2 )
  1:   On IDENTIFIER to state 59 with (1 )


State 90:
0: [P13 2] declarator -> declarator '['  . constant_expression ']'   { ')' ',' '[' ';' }  0
1: [P14 0] constant_expression ->  . INT_CONSTANT   { ']' }  1
2: [P15 0] constant_expression ->  . FLOAT_CONSTANT   { ']' }  2
3: [P16 0] constant_expression ->  . STRING_LITERAL   { ']' }  3
  0:   On constant_expression to state 115 with (0 )
  1:   On INT_CONSTANT to state 116 with (1 )
  2:   On FLOAT_CONSTANT to state 117 with (2 )
  3:   On STRING_LITERAL to state 118 with (3 )


State 91:
0: [P65 3] selection_statement -> IF '(' expression  . ')' statement ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ')' }  1
  0:   On ')' to state 119 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 92:
0: [P66 3] iteration_statement -> WHILE '(' expression  . ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ')' }  1
  0:   On ')' to state 120 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 93:
0: [P67 3] iteration_statement -> FOR '(' expression  . ';' expression ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ';' }  1
  0:   On ';' to state 121 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 94:
0: [P28 3] assignment_statement -> l_expression '=' expression  . ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ';' }  1
  0:   On ';' to state 122 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 95:
0: [P60 3] l_expression -> l_expression '[' expression  . ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ']' }  1
  0:   On ']' to state 123 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 96:
0: [P10 3] parameter_list -> parameter_list ',' parameter_declaration  .   { ')' ',' }  -1
  Reduce item(s): 0 


State 97:
0: [P30 3] expression -> expression OR_OP logical_and_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
1: [P32 1] logical_and_expression -> logical_and_expression  . AND_OP equality_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
  0:   On AND_OP to state 72 with (1 )
  Reduce item(s): 0 
Solved SR CONFLICT on AND_OP:
	shift to state 72, removed AND_OP from LA-set of rule 30)


State 98:
0: [P32 3] logical_and_expression -> logical_and_expression AND_OP equality_expression  .   { LE_OP GE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
1: [P34 1] equality_expression -> equality_expression  . EQ_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P35 1] equality_expression -> equality_expression  . NE_OP relational_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On EQ_OP to state 73 with (1 )
  1:   On NE_OP to state 74 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on EQ_OP:
	shift to state 73, removed EQ_OP from LA-set of rule 32)
Solved SR CONFLICT on NE_OP:
	shift to state 74, removed NE_OP from LA-set of rule 32)


State 99:
0: [P34 3] equality_expression -> equality_expression EQ_OP relational_expression  .   { EQ_OP NE_OP OR_OP AND_OP ')' ',' ']' ';' '+' '-' '*' '/' }  -1
1: [P37 1] relational_expression -> relational_expression  . '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P38 1] relational_expression -> relational_expression  . '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
3: [P39 1] relational_expression -> relational_expression  . LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
4: [P40 1] relational_expression -> relational_expression  . GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
  0:   On '<' to state 75 with (1 )
  1:   On '>' to state 76 with (2 )
  2:   On LE_OP to state 77 with (3 )
  3:   On GE_OP to state 78 with (4 )
  Reduce item(s): 0 
Solved SR CONFLICT on '<':
	shift to state 75, removed '<' from LA-set of rule 34)
Solved SR CONFLICT on '>':
	shift to state 76, removed '>' from LA-set of rule 34)
Solved SR CONFLICT on LE_OP:
	shift to state 77, removed LE_OP from LA-set of rule 34)
Solved SR CONFLICT on GE_OP:
	shift to state 78, removed GE_OP from LA-set of rule 34)


State 100:
0: [P35 3] equality_expression -> equality_expression NE_OP relational_expression  .   { EQ_OP NE_OP OR_OP AND_OP ')' ',' ']' ';' '+' '-' '*' '/' }  -1
1: [P37 1] relational_expression -> relational_expression  . '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P38 1] relational_expression -> relational_expression  . '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
3: [P39 1] relational_expression -> relational_expression  . LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  2
4: [P40 1] relational_expression -> relational_expression  . GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  3
  0:   On '<' to state 75 with (1 )
  1:   On '>' to state 76 with (2 )
  2:   On LE_OP to state 77 with (3 )
  3:   On GE_OP to state 78 with (4 )
  Reduce item(s): 0 
Solved SR CONFLICT on '<':
	shift to state 75, removed '<' from LA-set of rule 35)
Solved SR CONFLICT on '>':
	shift to state 76, removed '>' from LA-set of rule 35)
Solved SR CONFLICT on LE_OP:
	shift to state 77, removed LE_OP from LA-set of rule 35)
Solved SR CONFLICT on GE_OP:
	shift to state 78, removed GE_OP from LA-set of rule 35)


State 101:
0: [P37 3] relational_expression -> relational_expression '<' additive_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '*' '/' }  -1
1: [P42 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P43 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '+' to state 79 with (1 )
  1:   On '-' to state 80 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '+':
	shift to state 79, removed '+' from LA-set of rule 37)
Solved SR CONFLICT on '-':
	shift to state 80, removed '-' from LA-set of rule 37)


State 102:
0: [P38 3] relational_expression -> relational_expression '>' additive_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '*' '/' }  -1
1: [P42 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P43 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '+' to state 79 with (1 )
  1:   On '-' to state 80 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '+':
	shift to state 79, removed '+' from LA-set of rule 38)
Solved SR CONFLICT on '-':
	shift to state 80, removed '-' from LA-set of rule 38)


State 103:
0: [P39 3] relational_expression -> relational_expression LE_OP additive_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '*' '/' }  -1
1: [P42 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P43 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '+' to state 79 with (1 )
  1:   On '-' to state 80 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '+':
	shift to state 79, removed '+' from LA-set of rule 39)
Solved SR CONFLICT on '-':
	shift to state 80, removed '-' from LA-set of rule 39)


State 104:
0: [P40 3] relational_expression -> relational_expression GE_OP additive_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '*' '/' }  -1
1: [P42 1] additive_expression -> additive_expression  . '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P43 1] additive_expression -> additive_expression  . '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '+' to state 79 with (1 )
  1:   On '-' to state 80 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '+':
	shift to state 79, removed '+' from LA-set of rule 40)
Solved SR CONFLICT on '-':
	shift to state 80, removed '-' from LA-set of rule 40)


State 105:
0: [P42 3] additive_expression -> additive_expression '+' multiplicative_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' }  -1
1: [P45 1] multiplicative_expression -> multiplicative_expression  . '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P46 1] multiplicative_expression -> multiplicative_expression  . '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '*' to state 81 with (1 )
  1:   On '/' to state 82 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '*':
	shift to state 81, removed '*' from LA-set of rule 42)
Solved SR CONFLICT on '/':
	shift to state 82, removed '/' from LA-set of rule 42)


State 106:
0: [P43 3] additive_expression -> additive_expression '-' multiplicative_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' }  -1
1: [P45 1] multiplicative_expression -> multiplicative_expression  . '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
2: [P46 1] multiplicative_expression -> multiplicative_expression  . '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  1
  0:   On '*' to state 81 with (1 )
  1:   On '/' to state 82 with (2 )
  Reduce item(s): 0 
Solved SR CONFLICT on '*':
	shift to state 81, removed '*' from LA-set of rule 43)
Solved SR CONFLICT on '/':
	shift to state 82, removed '/' from LA-set of rule 43)


State 107:
0: [P45 3] multiplicative_expression -> multiplicative_expression '*' unary_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 108:
0: [P46 3] multiplicative_expression -> multiplicative_expression '/' unary_expression  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 109:
0: [P50 3] postfix_expression -> IDENTIFIER '(' ')'  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 110:
0: [P51 3] postfix_expression -> IDENTIFIER '(' expression_list  . ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
1: [P62 1] expression_list -> expression_list  . ',' expression   { ')' ',' }  1
  0:   On ')' to state 124 with (0 )
  1:   On ',' to state 125 with (1 )


State 111:
0: [P61 1] expression_list -> expression  .   { ')' ',' }  -1
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ')' ',' }  0
  0:   On OR_OP to state 71 with (1 )
  Reduce item(s): 0 


State 112:
0: [P54 3] primary_expression -> l_expression '=' expression  .   { LE_OP GE_OP EQ_OP NE_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  0
  0:   On OR_OP to state 71 with (1 )
  Reduce item(s): 0 
Solved SR CONFLICT on OR_OP:
	shift to state 71, removed OR_OP from LA-set of rule 54)


State 113:
0: [P58 3] primary_expression -> '(' expression ')'  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 114:
0: [P72 3] declarator_list -> declarator_list ',' declarator  .   { ',' ';' }  -1
1: [P13 1] declarator -> declarator  . '[' constant_expression ']'   { ',' '[' ';' }  0
  0:   On '[' to state 90 with (1 )
  Reduce item(s): 0 


State 115:
0: [P13 3] declarator -> declarator '[' constant_expression  . ']'   { ')' ',' '[' ';' }  0
  0:   On ']' to state 126 with (0 )


State 116:
0: [P14 1] constant_expression -> INT_CONSTANT  .   { ']' }  -1
  Reduce item(s): 0 


State 117:
0: [P15 1] constant_expression -> FLOAT_CONSTANT  .   { ']' }  -1
  Reduce item(s): 0 


State 118:
0: [P16 1] constant_expression -> STRING_LITERAL  .   { ']' }  -1
  Reduce item(s): 0 


State 119:
0: [P65 4] selection_statement -> IF '(' expression ')'  . statement ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P22 0] statement ->  . '{' statement_list '}'   { ELSE }  1
2: [P23 0] statement ->  . selection_statement   { ELSE }  2
3: [P24 0] statement ->  . iteration_statement   { ELSE }  3
4: [P25 0] statement ->  . assignment_statement   { ELSE }  4
5: [P26 0] statement ->  . RETURN expression ';'   { ELSE }  5
6: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { ELSE }  6
7: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { ELSE }  7
8: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { ELSE }  8
9: [P27 0] assignment_statement ->  . ';'   { ELSE }  9
10: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { ELSE }  10
11: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  11
12: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  10
  0:   On statement to state 127 with (0 )
  1:   On '{' to state 18 with (1 )
  2:   On selection_statement to state 19 with (2 )
  3:   On iteration_statement to state 20 with (3 )
  4:   On assignment_statement to state 21 with (4 )
  5:   On RETURN to state 22 with (5 )
  6:   On IF to state 24 with (6 )
  7:   On WHILE to state 25 with (7 )
  8:   On FOR to state 26 with (8 )
  9:   On ';' to state 27 with (9 )
  10:   On l_expression to state 28 with (10 12 )
  11:   On IDENTIFIER to state 29 with (11 )


State 120:
0: [P66 4] iteration_statement -> WHILE '(' expression ')'  . statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  1
2: [P23 0] statement ->  . selection_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  2
3: [P24 0] statement ->  . iteration_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  3
4: [P25 0] statement ->  . assignment_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  4
5: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  5
6: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  6
7: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  7
8: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  8
9: [P27 0] assignment_statement ->  . ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  9
10: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  10
11: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  11
12: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  10
  0:   On statement to state 128 with (0 )
  1:   On '{' to state 18 with (1 )
  2:   On selection_statement to state 19 with (2 )
  3:   On iteration_statement to state 20 with (3 )
  4:   On assignment_statement to state 21 with (4 )
  5:   On RETURN to state 22 with (5 )
  6:   On IF to state 24 with (6 )
  7:   On WHILE to state 25 with (7 )
  8:   On FOR to state 26 with (8 )
  9:   On ';' to state 27 with (9 )
  10:   On l_expression to state 28 with (10 12 )
  11:   On IDENTIFIER to state 29 with (11 )


State 121:
0: [P67 4] iteration_statement -> FOR '(' expression ';'  . expression ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ';' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ';' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ';' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ';' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ';' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ';' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' '[' ';' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 129 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 122:
0: [P28 4] assignment_statement -> l_expression '=' expression ';'  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 123:
0: [P60 4] l_expression -> l_expression '[' expression ']'  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' ']' ';' '=' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 124:
0: [P51 4] postfix_expression -> IDENTIFIER '(' expression_list ')'  .   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' ']' ';' '>' '+' '-' '*' '/' }  -1
  Reduce item(s): 0 


State 125:
0: [P62 2] expression_list -> expression_list ','  . expression   { ')' ',' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ')' ',' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ')' ',' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ')' ',' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ')' ',' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' ',' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' ',' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' ',' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' ',' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' ',' '[' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 130 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 126:
0: [P13 4] declarator -> declarator '[' constant_expression ']'  .   { ')' ',' '[' ';' }  -1
  Reduce item(s): 0 


State 127:
0: [P65 5] selection_statement -> IF '(' expression ')' statement  . ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
  0:   On ELSE to state 131 with (0 )


State 128:
0: [P66 5] iteration_statement -> WHILE '(' expression ')' statement  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 129:
0: [P67 5] iteration_statement -> FOR '(' expression ';' expression  . ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ';' }  1
  0:   On ';' to state 132 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 130:
0: [P62 3] expression_list -> expression_list ',' expression  .   { ')' ',' }  -1
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ')' ',' }  0
  0:   On OR_OP to state 71 with (1 )
  Reduce item(s): 0 


State 131:
0: [P65 6] selection_statement -> IF '(' expression ')' statement ELSE  . statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  1
2: [P23 0] statement ->  . selection_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  2
3: [P24 0] statement ->  . iteration_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  3
4: [P25 0] statement ->  . assignment_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  4
5: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  5
6: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  6
7: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  7
8: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  8
9: [P27 0] assignment_statement ->  . ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  9
10: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  10
11: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  11
12: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  10
  0:   On statement to state 133 with (0 )
  1:   On '{' to state 18 with (1 )
  2:   On selection_statement to state 19 with (2 )
  3:   On iteration_statement to state 20 with (3 )
  4:   On assignment_statement to state 21 with (4 )
  5:   On RETURN to state 22 with (5 )
  6:   On IF to state 24 with (6 )
  7:   On WHILE to state 25 with (7 )
  8:   On FOR to state 26 with (8 )
  9:   On ';' to state 27 with (9 )
  10:   On l_expression to state 28 with (10 12 )
  11:   On IDENTIFIER to state 29 with (11 )


State 132:
0: [P67 6] iteration_statement -> FOR '(' expression ';' expression ';'  . expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P29 0] expression ->  . logical_and_expression   { OR_OP ')' }  1
2: [P30 0] expression ->  . expression OR_OP logical_and_expression   { OR_OP ')' }  0
3: [P31 0] logical_and_expression ->  . equality_expression   { OR_OP AND_OP ')' }  2
4: [P32 0] logical_and_expression ->  . logical_and_expression AND_OP equality_expression   { OR_OP AND_OP ')' }  1
5: [P33 0] equality_expression ->  . relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  3
6: [P34 0] equality_expression ->  . equality_expression EQ_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
7: [P35 0] equality_expression ->  . equality_expression NE_OP relational_expression   { EQ_OP NE_OP OR_OP AND_OP ')' }  2
8: [P36 0] relational_expression ->  . additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  4
9: [P37 0] relational_expression ->  . relational_expression '<' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
10: [P38 0] relational_expression ->  . relational_expression '>' additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
11: [P39 0] relational_expression ->  . relational_expression LE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
12: [P40 0] relational_expression ->  . relational_expression GE_OP additive_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' }  3
13: [P41 0] additive_expression ->  . multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  5
14: [P42 0] additive_expression ->  . additive_expression '+' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
15: [P43 0] additive_expression ->  . additive_expression '-' multiplicative_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' }  4
16: [P44 0] multiplicative_expression ->  . unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  6
17: [P45 0] multiplicative_expression ->  . multiplicative_expression '*' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
18: [P46 0] multiplicative_expression ->  . multiplicative_expression '/' unary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  5
19: [P47 0] unary_expression ->  . postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  7
20: [P48 0] unary_expression ->  . unary_operator postfix_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  8
21: [P49 0] postfix_expression ->  . primary_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  9
22: [P50 0] postfix_expression ->  . IDENTIFIER '(' ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
23: [P51 0] postfix_expression ->  . IDENTIFIER '(' expression_list ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  10
24: [P52 0] postfix_expression ->  . l_expression INC_OP   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
25: [P63 0] unary_operator ->  . '-'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  12
26: [P64 0] unary_operator ->  . '!'   { INT_CONSTANT FLOAT_CONSTANT STRING_LITERAL IDENTIFIER '(' }  13
27: [P53 0] primary_expression ->  . l_expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
28: [P54 0] primary_expression ->  . l_expression '=' expression   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  11
29: [P55 0] primary_expression ->  . INT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  14
30: [P56 0] primary_expression ->  . FLOAT_CONSTANT   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  15
31: [P57 0] primary_expression ->  . STRING_LITERAL   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  16
32: [P58 0] primary_expression ->  . '(' expression ')'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP '<' ')' '>' '+' '-' '*' '/' }  17
33: [P59 0] l_expression ->  . IDENTIFIER   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  10
34: [P60 0] l_expression ->  . l_expression '[' expression ']'   { LE_OP GE_OP EQ_OP NE_OP OR_OP AND_OP INC_OP '<' ')' '[' '=' '>' '+' '-' '*' '/' }  11
  0:   On expression to state 134 with (0 2 )
  1:   On logical_and_expression to state 40 with (1 4 )
  2:   On equality_expression to state 41 with (3 6 7 )
  3:   On relational_expression to state 42 with (5 9 10 11 12 )
  4:   On additive_expression to state 43 with (8 14 15 )
  5:   On multiplicative_expression to state 44 with (13 17 18 )
  6:   On unary_expression to state 45 with (16 )
  7:   On postfix_expression to state 46 with (19 )
  8:   On unary_operator to state 47 with (20 )
  9:   On primary_expression to state 48 with (21 )
  10:   On IDENTIFIER to state 49 with (22 23 33 )
  11:   On l_expression to state 50 with (24 27 28 34 )
  12:   On '-' to state 51 with (25 )
  13:   On '!' to state 52 with (26 )
  14:   On INT_CONSTANT to state 53 with (29 )
  15:   On FLOAT_CONSTANT to state 54 with (30 )
  16:   On STRING_LITERAL to state 55 with (31 )
  17:   On '(' to state 56 with (32 )


State 133:
0: [P65 7] selection_statement -> IF '(' expression ')' statement ELSE statement  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 


State 134:
0: [P67 7] iteration_statement -> FOR '(' expression ';' expression ';' expression  . ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P30 1] expression -> expression  . OR_OP logical_and_expression   { OR_OP ')' }  1
  0:   On ')' to state 135 with (0 )
  1:   On OR_OP to state 71 with (1 )


State 135:
0: [P67 8] iteration_statement -> FOR '(' expression ';' expression ';' expression ')'  . statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  0
1: [P22 0] statement ->  . '{' statement_list '}'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  1
2: [P23 0] statement ->  . selection_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  2
3: [P24 0] statement ->  . iteration_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  3
4: [P25 0] statement ->  . assignment_statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  4
5: [P26 0] statement ->  . RETURN expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  5
6: [P65 0] selection_statement ->  . IF '(' expression ')' statement ELSE statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  6
7: [P66 0] iteration_statement ->  . WHILE '(' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  7
8: [P67 0] iteration_statement ->  . FOR '(' expression ';' expression ';' expression ')' statement   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  8
9: [P27 0] assignment_statement ->  . ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  9
10: [P28 0] assignment_statement ->  . l_expression '=' expression ';'   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  10
11: [P59 0] l_expression ->  . IDENTIFIER   { '[' '=' }  11
12: [P60 0] l_expression ->  . l_expression '[' expression ']'   { '[' '=' }  10
  0:   On statement to state 136 with (0 )
  1:   On '{' to state 18 with (1 )
  2:   On selection_statement to state 19 with (2 )
  3:   On iteration_statement to state 20 with (3 )
  4:   On assignment_statement to state 21 with (4 )
  5:   On RETURN to state 22 with (5 )
  6:   On IF to state 24 with (6 )
  7:   On WHILE to state 25 with (7 )
  8:   On FOR to state 26 with (8 )
  9:   On ';' to state 27 with (9 )
  10:   On l_expression to state 28 with (10 12 )
  11:   On IDENTIFIER to state 29 with (11 )


State 136:
0: [P67 9] iteration_statement -> FOR '(' expression ';' expression ';' expression ')' statement  .   { RETURN IF ELSE WHILE FOR IDENTIFIER '{' '}' ';' }  -1
  Reduce item(s): 0 



